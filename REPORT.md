# Отчет по нагрузочному тестированию: Сравнение REST (FastAPI) и gRPC

## 1. Описание приложений и среды

### Тестируемые приложения
Для эксперимента были взяты из прошлых заданий два микросервиса, реализующие функционал глоссария терминов.
* **REST API:** Реализован на базе фреймворка **FastAPI**. Использует стандартный `JSON` для обмена данными. Валидация через `Pydantic`.
* **gRPC API:** Реализован на базе `grpcio`. Использует протокол **HTTP/2** и бинарную сериализацию **Protobuf**.

**Важное замечание по архитектуре:**
Для обеспечения чистоты эксперимента и исключения влияния дисковой подсистемы (I/O), оба сервиса были настроены на использование **In-Memory хранилища** (Python dictionary). Это позволяет сравнить именно накладные расходы протоколов (сериализация, сеть), а не скорость записи на диск.

### Параметры тестовой среды
* **CPU:** ( AMD Ryzen 5)
* **RAM:** ( 16 GB)
* **OS:** (Windows)
* **Инструмент:** Locust

**Детальные результаты эксперимента можно посмотреть папке [assets](./assets/).**

## 2. Тестовые сценарии
Использовались два класса пользователей: `RestUser` (HTTP) и `GrpcUser` (RPC).
**Пропорции нагрузки:** 3 запроса на чтение (`GET`) к 1 запросу на запись (`POST`).

1.  **Sanity Check:** 10 пользователей, проверка работоспособности.
2.  **Normal Load:** 100 пользователей, эмуляция штатной работы.
3.  **Stress Test:** 1000 пользователей, поиск точки отказа.
4.  **Stability Test:** Длительная нагрузка (200 пользователей) для проверки деградации.

---

## 3. Результаты тестирования

### Сценарий 1: Sanity Check (Лёгкая нагрузка)
* **Параметры:** 10 users, spawn rate 1.
* **Результат:** Оба сервиса работают стабильно, ошибок нет.
* **Метрики:**
    * REST Avg Latency: ~2.5 ms
    * gRPC Avg Latency: ~1.0 ms

### Сценарий 2: Normal Load (Рабочая нагрузка)
* **Параметры:** 100 users, spawn rate 5.
* **Результат:**
    | Метрика | REST (FastAPI) | gRPC |
    | :--- | :--- | :--- |
    | RPS | ~18.6 | ~17 |
    | Avg Latency | **5 ms** | **1.5 ms** |
    | P95 Latency | 9 ms | 3 ms |
    | Ошибки | 0 | 0 |

**Анализ:** В нормальном режиме gRPC отвечает более чем в **3 раза быстрее** (1.5ms против 5ms), однако для пользователя разница пока не заметна глазом.

### Сценарий 3: Stress Test (Стресс-тест)
* **Параметры:** Нагрузка доведена до пика (около 1000 пользователей).
* **Результат:**
    | Метрика | REST (FastAPI) | gRPC |
    | :--- | :--- | :--- |
    | RPS (Total) | ~1.8 | ~59.2 |
    | Avg Latency | **6660 ms (6.6 сек)** | **8.6 ms** |
    | Max Latency | **139 000 ms** | 45 ms |
    | Ошибки | **510 (Всего)** | **0** |

**Анализ:**
Здесь произошло самое интересное.
1.  **Деградация REST:** При высокой нагрузке FastAPI перестал справляться. Среднее время ответа выросло до **6.6 секунд**, появились ошибки (Failures ~1%). Причина: высокие накладные расходы на сериализацию огромного JSON (размер ответа REST ~187 KB) блокировали Event Loop.
2.  **Устойчивость gRPC:** Сервис gRPC продолжил работать штатно. Время ответа выросло всего до **8.6 мс**. Ошибок — 0.

### Сценарий 4: Тест на стабильность
* **Параметры:** Средняя нагрузка, длительное время.
* **Результат:**
    * **REST:** Началась деградация. Avg Latency поднялся до **233 ms**, зафиксировано **211 ошибок**.
    * **gRPC:** Стабильная работа. Avg Latency **19 ms**, ошибок **0**.

---

## 4. Сравнительный анализ и Выводы

### Численное сравнение
* **Латентность (Latency):** В стрессовом режиме gRPC оказался быстрее в сотни раз (8ms против 6600ms). В обычном режиме — быстрее в 3 раза.
* **Пропускная способность:** gRPC смог обработать в разы больше запросов без ошибок, в то время как REST начал отбрасывать соединения.

### Анализ Overhead (Накладных расходов)
Главная причина краха REST в тесте №3 — это **размер сообщений и сериализация**.
* **REST:** Передает данные в текстовом формате JSON. Судя по логам, размер ответа составлял около **187 KB**. Сериализация такого объема данных в текст — дорогая операция для CPU.
* **gRPC:** Использует бинарный формат Protobuf. Сообщения компактнее, а парсинг (marshal/unmarshal) происходит гораздо быстрее и потребляет меньше CPU.

### Итоговый вывод
Эксперимент наглядно показал границы применимости технологий:
1.  **FastAPI (REST)** отлично подходит для обычных веб-сервисов и публичных API с умеренной нагрузкой. Однако передача больших объемов данных (списков объектов) в JSON становится узким местом при высокой нагрузке.
2.  **gRPC** показал феноменальную производительность и устойчивость. Даже под стрессовой нагрузкой сервис не упал и отдавал ответы почти мгновенно (менее 10мс).

**Рекомендация:** Для высоконагруженных внутренних микросервисов, где важна скорость и передаются большие структуры данных, использование **gRPC является строго рекомендуемым**.

**Вывод:** Использование gRPC вместо REST в рабочих микросервисах **сильно ускоряет работу**.



***Спасибо за внимание!***